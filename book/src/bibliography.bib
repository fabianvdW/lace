@article{koka,
  title        = {Koka: Programming with Row Polymorphic Effect Types},
  volume       = {153},
  issn         = {2075-2180},
  url          = {http://arxiv.org/abs/1406.2061v1},
  doi          = {10.4204/EPTCS.153.8},
  shorttitle   = {Koka},
  pages        = {100--126},
  journaltitle = {Electronic Proceedings in Theoretical Computer Science},
  shortjournal = {Electron. Proc. Theor. Comput. Sci.},
  author       = {Leijen, Daan},
  urldate      = {2023-06-16},
  date         = {2014-06-05},
  langid       = {english},
  file         = {Full Text:/home/terts/Zotero/storage/M9WVE4MJ/Leijen - 2014 - Koka Programming with Row Polymorphic Effect Type.pdf:application/pdf}
}

@inproceedings{koka-async,
  location   = {Oxford {UK}},
  title      = {Structured asynchrony with algebraic effects},
  isbn       = {978-1-4503-5183-6},
  url        = {https://dl.acm.org/doi/10.1145/3122975.3122977},
  doi        = {10.1145/3122975.3122977},
  eventtitle = {{ICFP} '17: {ACM} {SIGPLAN} International Conference on Functional Programming},
  pages      = {16--29},
  booktitle  = {Proceedings of the 2nd {ACM} {SIGPLAN} International Workshop on Type-Driven Development},
  publisher  = {{ACM}},
  author     = {Leijen, Daan},
  urldate    = {2023-06-19},
  date       = {2017-09-03},
  langid     = {english},
  file       = {Leijen - 2017 - Structured asynchrony with algebraic effects.pdf:/home/terts/Zotero/storage/GDRP67J5/Leijen - 2017 - Structured asynchrony with algebraic effects.pdf:application/pdf}
}

@inproceedings{koka-compilation,
  location   = {Paris France},
  title      = {Type directed compilation of row-typed algebraic effects},
  isbn       = {978-1-4503-4660-3},
  url        = {https://dl.acm.org/doi/10.1145/3009837.3009872},
  doi        = {10.1145/3009837.3009872},
  eventtitle = {{POPL} '17: The 44th Annual {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
  pages      = {486--499},
  booktitle  = {Proceedings of the 44th {ACM} {SIGPLAN} Symposium on Principles of Programming Languages},
  publisher  = {{ACM}},
  author     = {Leijen, Daan},
  urldate    = {2023-04-08},
  date       = {2017-01},
  langid     = {english},
  file       = {Leijen - Type Directed Compilation of Row-Typed Algebraic E.pdf:/home/terts/Zotero/storage/GYJ3MYKX/Leijen - Type Directed Compilation of Row-Typed Algebraic E.pdf:application/pdf}
}

@article{koka-named-handlers,
	title = {First-class names for effect handlers},
	volume = {6},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3563289},
	doi = {10.1145/3563289},
	abstract = {Algebraic effects and handlers are a promising technique for incorporating composable computational effects into functional programming languages. Effect handlers enable concisely programming with different effects, but they do not offer a convenient way to program with different instances of the same effect. As a solution to this inconvenience, previous studies have introduced \_named effect handlers\_, which allow the programmer to distinguish among different effect instances. However, existing formalizations of named handlers are both involved and restrictive, as they employ non-standard mechanisms to prevent the escaping of handler names.
            In this paper, we propose a simple and flexible design of named handlers. Specifically, we treat handler names as first-class values, and prevent their escaping while staying within the ordinary λ-calculus. Such a design is enabled by combining named handlers with \_scoped effects\_, a novel variation of effects that maintain a scope via rank-2 polymorphism. We formalize two combinations of named handlers and scoped effects, and implement them in the Koka programming language. We also present practical applications of named handlers, including a neural network and a unification algorithm.},
	pages = {30--59},
	issue = {{OOPSLA}2},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Xie, Ningning and Cong, Youyou and Ikemori, Kazuki and Leijen, Daan},
	urldate = {2023-06-13},
	date = {2022-10-31},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/A6I2B7DV/Xie et al. - 2022 - First-class names for effect handlers.pdf:application/pdf},
}

@article{effekt,
  title        = {Effects as capabilities: effect handlers and lightweight effect polymorphism},
  volume       = {4},
  issn         = {2475-1421},
  url          = {https://dl.acm.org/doi/10.1145/3428194},
  doi          = {10.1145/3428194},
  shorttitle   = {Effects as capabilities},
  abstract     = {Effect handlers have recently gained popularity amongst programming language researchers. Existing type- and effect systems for effect handlers are often complicated and potentially hinder a wide-spread adoption. We present the language Effekt with the goal to close the gap between research languages with effect handlers and languages for working programmers. The design of Effekt revolves around a different view of effects and effect types. Traditionally, effect types express which side effects a computation might have. In Effekt, effect types express which capabilities a computation requires from its context. While this new point in the design space of effect systems impedes reasoning about purity, we demonstrate that it simplifies the treatment of effect polymorphism and the related issues of effect parametricity and effect encapsulation. To guarantee effect safety, we separate functions from values and treat all functions as second-class. We define the semantics of Effekt as a translation to System Xi, a calculus in explicit capability-passing style.},
  pages        = {1--30},
  issue        = {{OOPSLA}},
  journaltitle = {Proceedings of the {ACM} on Programming Languages},
  shortjournal = {Proc. {ACM} Program. Lang.},
  author       = {Brachthäuser, Jonathan Immanuel and Schuster, Philipp and Ostermann, Klaus},
  urldate      = {2023-06-02},
  date         = {2020-11-13},
  langid       = {english},
  file         = {Full Text:/home/terts/Zotero/storage/3TRIMRJ3/Brachthäuser et al. - 2020 - Effects as capabilities effect handlers and light.pdf:application/pdf}
}

@inproceedings{idris,
	location = {Boston Massachusetts {USA}},
	title = {Programming and reasoning with algebraic effects and dependent types},
	isbn = {978-1-4503-2326-0},
	url = {https://dl.acm.org/doi/10.1145/2500365.2500581},
	doi = {10.1145/2500365.2500581},
	eventtitle = {{ICFP}'13: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {133--144},
	booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {{ACM}},
	author = {Brady, Edwin},
	urldate = {2023-06-13},
	date = {2013-09-25},
	langid = {english},
	file = {Full Text:/home/terts/Zotero/storage/LX5AKT74/Brady - 2013 - Programming and reasoning with algebraic effects a.pdf:application/pdf},
}

@misc{frank,
	title = {Do be do be do},
	url = {http://arxiv.org/abs/1611.09259},
	abstract = {We explore the design and implementation of Frank, a strict functional programming language with a bidirectional effect type system designed from the ground up around a novel variant of Plotkin and Pretnar’s effect handler abstraction.},
	number = {{arXiv}:1611.09259},
	publisher = {{arXiv}},
	author = {Lindley, Sam and {McBride}, Conor and {McLaughlin}, Craig},
	urldate = {2023-04-08},
	date = {2017-10-03},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1611.09259 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {Lindley et al. - 2017 - Do be do be do.pdf:/home/terts/Zotero/storage/HVDS8XC9/Lindley et al. - 2017 - Do be do be do.pdf:application/pdf},
}

@inproceedings{ocaml,
	title = {Retrofitting Effect Handlers onto {OCaml}},
	url = {http://arxiv.org/abs/2104.00250},
	doi = {10.1145/3453483.3454039},
	abstract = {Effect handlers have been gathering momentum as a mechanism for modular programming with user-defined effects. Effect handlers allow for non-local control flow mechanisms such as generators, async/await, lightweight threads and coroutines to be composably expressed. We present a design and evaluate a full-fledged efficient implementation of effect handlers for {OCaml}, an industrial-strength multi-paradigm programming language. Our implementation strives to maintain the backwards compatibility and performance profile of existing {OCaml} code. Retrofitting effect handlers onto {OCaml} is challenging since {OCaml} does not currently have any nonlocal control flow mechanisms other than exceptions. Our implementation of effect handlers for {OCaml}: (i) imposes a mean 1\% overhead on a comprehensive macro benchmark suite that does not use effect handlers; (ii) remains compatible with program analysis tools that inspect the stack; and (iii) is efficient for new code that makes use of effect handlers.},
	pages = {206--221},
	booktitle = {Proceedings of the 42nd {ACM} {SIGPLAN} International Conference on Programming Language Design and Implementation},
	author = {Sivaramakrishnan, K. C. and Dolan, Stephen and White, Leo and Kelly, Tom and Jaffer, Sadiq and Madhavapeddy, Anil},
	urldate = {2023-04-08},
	date = {2021-06-19},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {2104.00250 [cs]},
	keywords = {Computer Science - Programming Languages, D.3.3},
	file = {Sivaramakrishnan et al. - 2021 - Retrofitting Effect Handlers onto OCaml.pdf:/home/terts/Zotero/storage/GPMXK3JR/Sivaramakrishnan et al. - 2021 - Retrofitting Effect Handlers onto OCaml.pdf:application/pdf},
}